<!DOCTYPE html>
<html>
<head>
    <title>Dragit!</title>
    <style>
    @keyframes stretchdown {
        from {
            padding-bottom: 0px;
            border-bottom: 0px;
        }
        to {
            padding-bottom: 32px;
            border-bottom: 1px solid #ff4f4f;
        }
    }

    :root {
        --grid-border-color: #929292;

        --font-color-default: #252525;
        --font-color-dropped: #fafafa;

        --outline-input-color: #458bdc;

        --row-even-bg-color: #bbe3fc;
        --row-odd-bg-color: #f0f0f0;
        --row-even-hover-bg-color: #a5c9e1;
        --row-odd-hover-bg-color: #eaeaea;
    }

    * {
        margin: 0;
        padding: 0;
    }

    html {
        height: 100%;
        font-size: 2vw;
    }

    body {
        background: #0f0f0f;
        height: 100%;
        font-family: Arial, Helvetica, sans-serif;
    }

    #content {
        width: 90%;
        height: 90%;
        background: #f0f0f0;
        margin: auto;
        position: relative;
        border-left: 1px solid var(--grid-border-color);
        border-right: 1px solid var(--grid-border-color);
        user-select: none;
        overflow: auto;
    }

    .row {
        width: 100%;
        border-bottom: 1px solid var(--grid-border-color);
        background: #f7f8f8;
        font-size: 0.3em;
        color: #252525;
    }

    .row.head {
        font-weight: bold;
        position: sticky;
        top: 0;
        left: 0;
    }

    .row:has(.empty), .row.hovered {
        animation: 70ms 1 forwards stretchdown
    }

    .row:first-child {
        border-top: 1px solid var(--grid-border-color);
    }

    .row.lonely:nth-child(even) {
        background: var(--row-even-bg-color);
    }
    
    .row.lonely:nth-child(even):hover {
        background: var(--row-even-hover-bg-color);
    }

    .row:nth-child(odd):hover {
        background: var(--row-odd-hover-bg-color);
    }

    .empty {
        height: 0px;
        display: block;
        width: 100%;
        background:#f7f8f8;
        border-top: 1px solid var(--grid-border-color);
    }

    .row.dragged {
        border: 1px dashed var(--grid-border-color);
        font-size: 0.25em;
        filter: drop-shadow(0 0 8px rgba(85, 85, 85, 0.5));
        filter: opacity(74%);
    }

    .cell {
        border-right: 1px solid var(--grid-border-color);
        display: inline-block;
        vertical-align: top;
        padding: 8px 12px;
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .cell.editable {
        cursor: pointer;
    }
    
    .cell input {
        width: 97%;
        display: block;
        padding: 9px 4px;
        margin: auto;
        border: none;
        outline: 2px solid var(--outline-input-color);
        font-family: Arial, Helvetica, sans-serif;
    }

    .draggable {
        cursor: move;
    }

    .cell.draggable {
        text-align: center;
    }

    .row.hovered .cell {
        border-bottom: 1px solid #ff4f4f;
    }

    .head .cell, .cell.editable:has(input) {
        cursor: default;
    }

    .cell.editable:has(input) {
        padding: 0;
    }

    .cell:last-child {
        border: 0;
    }

    </style>
</head>
<body>
    <div id="content">
    </div>

    <script>
    (function(window, document, undefined) {

        const clearElementInnerHTML = (element) => {
             while(element.firstChild)
                element.removeChild(element.firstChild);
        };

        const generateLoremText = (numParagraphs, numWords, words) => {
            let loremText = '';
            words = words || [
                'Lorem',
                'ipsum',
                'dolor',
                'sit',
                'amet',
                'consectetur',
                'adipiscing',
                'elit',
                'sed',
                'do',
                'eiusmod',
                'tempor',
                'incididunt',
                'ut',
                'ut',
                'labore',
                'et',
                'dolore',
                'magna',
                'magnam',
                'aliqua',
                'Ut',
                'enim',
                'in',
                'ad',
                'minim',
                'veniam',
                'quis',
                'nostrud',
                'exercitation',
                'ullamco',
                'laboris',
                'nisi',
                'ut',
                'aliquip',
                'ex',
                'ea',
                'commodo',
                'consequat',
                'Duis',
                'aute',
                'irure',
                'et',
                'est',
                'dolor',
                'in',
                'reprehenderit',
                'in',
                'voluptate',
                'velit',
                'esse',
                'cillum',
                'dolore',
                'eu',
                'fugiat',
                'nulla',
                'pariatur',
                'Excepteur',
                'sint',
                'occaecat',
                'cupidatat',
                'non',
                'proident',
                'sunt',
                'in',
                'culpa',
                'qui',
                'quid',
                'quam',
                'quo',
                'officia',
                'deserunt',
                'mollit',
                'morietur',
                'anim',
                'id',
                'est',
                'laborum',
                'besto',
                '10',
                '11',
                '12',
                '22',
                '28',
                'Itaque',
                'modorenai',
                'earum',
                'rerum',
                'Maximus',
                'tenetur',
                'a',
                'sapiente',
                'dominam',
                'facilis',
                '1',
                '2',
                'quidem',
                '5',
                '8',
                'vorbis',
                'comentitur',
                'tremens',
                'quando',
                'Regis',
                'expectare',
                'vel',
                'voluptas',
                'quam',
                'nihil',
                'molestiae',
                'consequatur',
                'autem',
                'Quis',
                'eum',
                'iure',
                'corpum',
                'Corpus',
                'magnam',
                'aliquam',
                'quaerat',
                'voluptatem',
                'fugit',
                'perspiciatis',
                'error',
                'accusantium',
                'doloremque',
                'laudantium',
                'totam',
                'rem',
                'aperiam',
                'arepam',
                'architecto',
                'beatae',
                'vitae',
                'dicta',
                'loream',
                'explicabo',
                'Nemo',
                'Lucius',
                'aqua',
                'dignissimos',
                'ducimus',
                'blanditiis',
                'praesentium',
                'voluptatum',
                'deleniti',
                'atque',
                'corrupti',
                'quos',
                'dolores',
                'quas',
                'molestias',
                'excepturi',
                'sint',
                'occaecati',
                'et',
                'cupiditate',
                'provident',
                'in',
                'similique',
                'sunt',
                'mollitia',
                'animi',
                'voluptatibus',
                'maiores',
                'recusandae',
                'cuius',
                'accusamus',
                'doloribus',
                'asperiores',
                'perferendis',
                'repellat',
                'assumenda'
            ];

            for (let i = 0; i < numParagraphs; i++) {
                let paragraph = '';
                for (let j = 0; j < numWords; j++) {
                    let randomWord = words[Math.floor(Math.random() * words.length)];
                    paragraph += randomWord + ' ';
                }
                loremText += paragraph;
            }
            return loremText;
        }

        const randomStr = (length) => {
            let result = '',
                characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZa bcdefghijklmnopqrstuvwxyzàéù0123456789-',
                charactersLength = characters.length;
            for (let i = 0; i < length; ++i) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        }

        const htmlEntities = (rawStr) => {
            return rawStr.replace(/[\u00A0-\u9999<>\&]/g, function(i) {
                return '&#'+i.charCodeAt(0)+';';
            });
        }

        const getOffsetLeft = (elem) => {
            let offset = 0;
            while (elem.parentElement) {
                    offset += elem.parentElement.offsetLeft;
                    elem = elem.parentElement;
            }
            return offset;
        }

        getLastParent = (elem) => {
            while(elem.parentElement && elem.parentElement != document.body) {
                elem = elem.parentElement;
            }

            return elem;
        }

        const getButton = (key) => {
            const buttons = {
                0: 'uninitialized',
                1: 'leftClick',
                2: 'rightClick',
                4: 'middle',
                8: 'back',
                16: 'forward'
            };
            if (buttons.hasOwnProperty(key))
                return buttons[key];
            return 'unknown';
        };

        const getCursor = (evt) => {
            return {
                X: evt.clientX,
                Y: evt.clientY,
                buttons: getButton(evt.buttons)
            }
        }

        const OneEvent = function(callback) {
            this.callback = callback;
        }
        OneEvent.prototype = {
            trigger(args) {
                this.callback(...args);
            }
        };

        const ListEvents = function() {
            this._eventsRegistered = [];
        };
        ListEvents.prototype = {
            onEventRegister({cb, subscriber}, eventKey) {
                this._eventsRegistered.push({'eventKey': eventKey, 'subscriber': subscriber,  'event': new OneEvent(cb)});
            },
            unsubscribeEVent({eventKey, subscriber}) {
                const subInedx = this._eventsRegistered.findIndex(evt => evt.subscriber == subscriber && evt.eventKey == eventKey);
                if (typeof subInedx === 'undefined')
                    return;
                this._eventsRegistered.splice(subInedx, 1);
            },
            trigger(eventKey, ...args) {
                args = args || [];
                this._onEventTrigger(eventKey, args);
            },
            _onEventTrigger(eventKey, args) {
                const evts = this._eventsRegistered.filter(evt => evt.eventKey == eventKey);
                if (evts.length == 0)
                    return;
                for (let i = 0; i < evts.length; ++i) {
                    evts[i].event.trigger(args);
                }
            },
            _checkEventKey(eventKey) {
                const indx = this._eventsRegistered.findIndex(evt => evt.eventKey == eventKey);
                if (indx != -1) {
                    console.error(`Event ${eventKey} already register`);
                    throw `Event ${eventKey} already register`;
                }
            },
        };

        const DragmeMover = function(dragme) {
            this.dragme = dragme;
        }
        DragmeMover.prototype = {
            init(seekParent) {
                return this.dragme.init(seekParent);
            },
            moveTo(x, y, seekParent) {
                if (this.prevX && this.prevY) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX),
                        dragY = this.dragme.offsetTop() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.setLeftTop.bind(this.dragme, dragX, dragY));
                }

                this.prevX = x;
                this.prevY = y;
            },
            moveXTo(x) {
                if (this.prevX) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX);
                    requestAnimationFrame(this.dragme.left.bind(this.dragme, dragX, 'px'));
                }

                this.prevX = x;
            },
            moveYTo(y) {
                if (this.prevY) {
                    let dragY = this.dragme.offsetLeft() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.top.bind(this.dragme, dragY, 'px'));
                }

                this.prevY = y;
            },
            done() {
                this.prevX = undefined;
                this.prevY = undefined;
                this.dragme.reset();
            },
            getDragme() {
                return this.dragme;
            }
        };

        const DragIt = function(dragMover) {
            this.dragMover = dragMover;
            this.pressed = false;
        }
        DragIt.prototype = {
            setDragMover(dragMover) {
                this.dragMover = dragMover;
            },
            getDragMover() {
                return this.dragMover;
            },
            getDragme(seekParent) {
                return this.dragMover.getDragme();
            },
            setDragmeSeekParent() {
                this.dragMover.getDragme().setSeekParent();
            },
            unsetDragmeSeekParent() {
                this.dragMover.getDragme().unsetSeekParent();
            },
            dragit(cursor, seekParent) {
                if (cursor.buttons != 'leftClick')
                    return;
                                
                if (!this._isInit)
                    this._init(seekParent);
                this.pressed = true;

                this.getDragme().dispatchEvent('dragged');

                this.dragMover.moveTo(cursor.X, cursor.Y);
            },
            dragmove(cursor, seekParent) {
                if (this.pressed)
                    this.dragit(cursor, seekParent);
            },
            dragstop(cursor) {
                if (!this.pressed)
                    return;

                this.getDragme().dispatchEvent('dropped');

                this._finish();
            },
            insertDragAfter(drag, seekParent) {
                let dragme = drag.getDragme(), 
                    thisdragme = this.getDragme();
                if (seekParent) {
                    dragme = dragme.getParentItem();
                    thisdragme = thisdragme.getParentItem();
                }

                thisdragme.insertItemAfter(dragme, true);
            },
            toggleHovered(hovered) {
               this.getDragme().toggleHovered(hovered)
            },
            _init(seekParent) {
                this._isInit = this.dragMover.init(seekParent);
            },
            _finish() {
                this.pressed = false;
                this._isInit = false;
                this.dragMover.done();
                if (this.onFinish && typeof this.onFinish === 'function')
                    this.onFinish(this);
            }
        }

        const DragitManager = function(drags) {
            this.drags = drags || [];
            this.seekParent = false;
        }
        DragitManager.prototype = {
            activate(elementsArray, seekParent) {
                this.seekParent = seekParent;
                this._bindedDragit = this._dragit.bind(this);
                this._bindedDragmove = this._dragmove.bind(this);
                this._bindedDragstop = this._dragstop.bind(this);

                document.addEventListener('mousedown', this._bindedDragit);
                document.addEventListener('mousemove', this._bindedDragmove);
                document.addEventListener('mouseup', this._bindedDragstop);

                if (elementsArray)
                    this.setDrags(elementsArray);

                this.activated = true;
            },
            setDrags(elementsArray) {
                for (let i = 0; i < elementsArray.length; ++i) {
                    this.drags.push(new DragIt(new DragmeMover(elementsArray[i])));
                }
            },
            deactivate() {
                if (!this.activated)
                    return;

                document.removeEventListener('mousedown', this._bindedDragit);
                document.removeEventListener('mousemove', this._bindedDragmove);
                document.removeEventListener('mouseup', this._bindedDragstop);

                this._bindedDragit = null;
                this._bindedDragmove = null;
                this._bindedDragstop = null;

                this.activated = false;
            },
            _dragit(evt) {
                this._findCursorHoveredDrag(getCursor(evt), (drag, cursor) => {
                    drag.dragit(cursor, this.seekParent);
                    this.currentDrag = drag;
                });
            },
            _dragmove(evt) {
                if (!this.currentDrag)
                    return;

                const drag = this._findHoveredDrag(this.currentDrag);

                if (drag && drag != this.hoveredDrag) {
                    if (this.hoveredDrag) {
                        if (this.seekParent)
                            this.hoveredDrag.setDragmeSeekParent();
                        this.hoveredDrag.getDragme().toggleHovered();
                        if (this.seekParent)
                            this.hoveredDrag.unsetDragmeSeekParent();
                    }
                    if (this.seekParent)
                        drag.setDragmeSeekParent();
                    drag.getDragme().toggleHovered();
                    if (this.seekParent)
                        drag.unsetDragmeSeekParent();
                    this.hoveredDrag = drag;
                }

                this.currentDrag.dragmove(getCursor(evt), this.seekParent);
            },
            _dragstop(evt) {
                if (!this.currentDrag)
                    return;

                let drag = this._findHoveredDrag(this.currentDrag);

                if (this.hoveredDrag) {
                     if (this.seekParent)
                        this.hoveredDrag.setDragmeSeekParent();
                    this.hoveredDrag.getDragme().toggleHovered();
                    if (this.seekParent)
                        this.hoveredDrag.unsetDragmeSeekParent();
                }

                if (drag) {
                    this.currentDrag.insertDragAfter(drag, this.seekParent);
                }

                this.currentDrag.dragstop(getCursor(evt), this.seekParent);
                this.currentDrag = undefined;
                this.hoveredDrag = undefined;
            },
            _divContainsDrag(drag, div) {
                const dragOffsetLeft = drag.offsetLeft() + (drag.offsetWidth() / 2);
                const dragOffsetTop = drag.offsetTop() + (drag.offsetHeight() / 2);

                return (dragOffsetLeft >= div.offsetLeft() && dragOffsetLeft < div.offsetRight()) &&
                       (dragOffsetTop  >= div.offsetTop()  && dragOffsetTop  < div.offsetBottom());
            },
            _TargetContainsCursor(cursor, target) {
                const X = cursor.X + target.scrollLeft();
                const Y = cursor.Y + target.scrollTop();

                return X > target.offsetLeft(true) && X < target.offsetRight(true) &&
                       Y > target.offsetTop()      && Y < target.offsetBottom();
            },
            _findCursorHoveredDrag(cursor, cb) {
                for (let i = 0; i < this.drags.length; ++i) {
                    let drag = this.drags[i];
                    if (this._TargetContainsCursor(cursor, drag.getDragme())) {
                        if (typeof cb === 'function')
                            cb(drag, cursor);
                        break;
                    }
                }
            },
            _findHoveredDrag(drag) {
                let foundDrag;
                for (let i = 0; i < this.drags.length; ++i) {
                    let dr = this.drags[i];
                    if (dr.getDragme() == drag.getDragme())
                        continue;
                    if (this.seekParent)
                        dr.setDragmeSeekParent();
                    if (this._divContainsDrag(drag.getDragme(), dr.getDragme())) {
                        if (this.seekParent)
                            dr.unsetDragmeSeekParent();
                        foundDrag = dr;
                        break;
                    }
                    if (this.seekParent)
                        dr.unsetDragmeSeekParent();
                }

                return foundDrag;
            }
        };

        const HTMLItems = function(elementName) {
            this.element = document.createElement(elementName);
            this.events = {};
        };
        HTMLItems.prototype = {
            render() {
                return this.element;
            },
            getParent() {
                return this.element.parentElement;
            },
            setParentItem(htmlItem) {
                this.parentItem = htmlItem;
            },
            getParentItem(htmlItem) {
                return this.parentItem;
            },
            width(width, unit) {
                if (typeof width === 'number')
                    this.element.style.width = `${width}${unit}`;
                else
                    return this.element.style.width;
            },
            height(height, unit) {
                if (typeof height === 'number')
                    this.element.style.height = `${height}${unit}`;
                else
                    return this.element.style.height;
            },
            left(left, unit) {
                if (typeof left === 'number')
                    this.element.style.left = `${left}${unit}`;
                else
                    return this.element.style.left;
            },
            top(top, unit) {
                if (typeof top === 'number')
                    this.element.style.top = `${top}${unit}`;
                else
                    return this.element.style.top;
            },
            offsetTop() {
                return this.element.offsetTop;
            },
            offsetLeft(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.element);
                }
                return this.element.offsetLeft + margin;
            },
            offsetRight(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.element);
                }
                return this.element.offsetLeft + this.element.offsetWidth + margin;
            },
            offsetBottom() {
                return this.element.offsetTop + this.element.offsetHeight;
            },
            offsetWidth() {
                return this.element.offsetWidth;
            },
            offsetHeight() {
                return this.element.offsetHeight;
            },
            setLeftTop(left, top) {
                this.element.style.left = `${left}px`;
                this.element.style.top = `${top}px`;
            },
            scrollTop() {
                const parentElem = getLastParent(this.element);
                return parentElem.scrollTop;
            },
            scrollLeft() {
                const parentElem = getLastParent(this.element);
                return parentElem.scrollLeft;
            },
            innerContent(content) {
                if (typeof content !== 'undefined')
                    this.render(true).innerHTML = content;
                else
                    return this.render(true).innerHTML;
            },
            append(...elements) {
                this.element.append(...elements.map(el => el.render()));
            },
            css(style, replace) {
                style = style || {};
                if (!replace)
                    style = {...this.element.style, ...style};

                Object.keys(style).forEach(k => this.element.style[k] = style[k]);
            },
            data({name, value}) {
                this.element.dataset[name] = value;
            },
            insertItemAfter(thisInstance, d) {
                thisInstance.element.insertAdjacentElement('afterend', this.render());
            },
            addEventListener(evtName, cb) {
                this.element.addEventListener(evtName, cb);
            },
            createCustomEvent(evtName, options) {
                if (this.events.hasOwnProperty(evtName))
                    return console.error(`Event ${evtName} already set`);

                options = options || {detail: {HTMLItem: this}};
                
                this.events[evtName] = new CustomEvent(evtName, options);
            },
            dispatchEvent(evtName) {
                if (!this.events.hasOwnProperty(evtName))
                    return console.error(`Unknown event name ${evtName}`);
                
                this.render().dispatchEvent(this.events[evtName]);
            },
        }

        const HTMLIndexedItems = function(elementName) {
            HTMLItems.call(this, elementName);
            this.index = 0;
            this.eventsList = new ListEvents();
        };
        HTMLIndexedItems.prototype = {
            setIndex(index) {
                this.index = index;
                this.data({name: 'index', value: index});
            },
            updateIndex(index) {
                this.eventsList.trigger('onIndexUpdate', index, this.index, this);
                this.setIndex(index);
            },
            getIndex() {
                return this.index;
            },
            onIndexUpdate(cb, subscriber) {
                this.eventsList.onEventRegister({cb, subscriber}, 'onIndexUpdate');
            },
            insertItemAfter(thisInstance) {
                let thisInstanceIdx = thisInstance.getIndex();
                if (this.index > thisInstanceIdx)
                    thisInstanceIdx++;
                this.updateIndex(thisInstanceIdx);
                thisInstance.element.insertAdjacentElement('afterend', this.render());
            }
        }

        const HTMLDraggableItems = function(elementName) {
            HTMLIndexedItems.call(this, elementName);
            this._setupEvents();
        }
        HTMLDraggableItems.prototype = {
            render(getReal) {
                if (getReal && this.seekParent) {
                    return this.element.querySelector('.draggable');
                }
                return this.element;
            },
            setSeekParent() {
                this.seekParent = true;
                this.element =  this.element.parentElement;
            },
            unsetSeekParent() {
                this.seekParent = false;
                this.element = this.element.querySelector('.draggable');
            },
            toggleHovered() {
                this.element.classList.toggle('hovered')
            },
            setDraggable(draggable) {
                if (draggable)
                    this.element.classList.add('draggable');
                else
                    this.element.classList.remove('draggable');
                this.draggable = draggable;
            },
            isDraggable() {
                return this.draggable;
            },
            onDragged(cb) {
                this.addEventListener('dragged', cb);
            },
            onDropped(cb) {
                this.addEventListener('dropped', cb);
            },
            init(seekParent) {
                if (!this.element)
                    return false;

                if (seekParent)
                    this.setSeekParent();

                this.css({
                    position: 'absolute',
                    left: `${this.offsetLeft()}px`,
                    top: `${this.offsetTop()}px`,
                    zIndex: 100,
                });

                this.element.classList.add('dragged');

                return true;
            },
            reset() {
                this.css({
                    position: 'static',
                });

                const droppedAnimation = new DroppedAnimation(this.element);
                
                droppedAnimation.start(790, (element) => {
                    element.classList.remove('dragged');
                });

                if (this.seekParent)
                    this.unsetSeekParent();
            },
            dispatchEvent(evtName) {
                if (!this.events.hasOwnProperty(evtName))
                    return console.error(`Unknown event name ${evtName}`);
                
                this.render(true).dispatchEvent(this.events[evtName]);
            },
            _setupEvents() {
                this.createCustomEvent('dragged');
                this.createCustomEvent('dropped');
            }
        }

        Object.setPrototypeOf(HTMLIndexedItems.prototype, HTMLItems.prototype);
        Object.setPrototypeOf(HTMLDraggableItems.prototype, HTMLIndexedItems.prototype);
        const DroppedAnimation = function(element) {
            this.element = element;
        }
        DroppedAnimation.prototype = {
            start(timeout, onFinish) {
                timeout = timeout || 1000;
                const animation = this._setupDroppedAnimation(this.element, timeout);
                animation.onfinish = () => {
                    if (typeof onFinish == 'function')
                        onFinish(this.element);
                };

                animation.play();
            },
            _setupDroppedAnimation(element, timeout) {
                let elementBGColor = element.style.background;
                
                if (!elementBGColor) {
                    let computedStyle = window.getComputedStyle(element);
                    if (computedStyle.getPropertyValue('background-color'))
                        elementBGColor = computedStyle.getPropertyValue('background-color');
                    else if (computedStyle.getPropertyValue('background'))
                        elementBGColor = computedStyle.getPropertyValue('background');
                    else
                        elementBGColor = 'inherit';
                }
                
                const keyFrames = [
                    {background: elementBGColor, fontSize: '0.25em'},
                    {background: '#7fdb8860', fontSize: '0.25em'},
                    {background: '#7fdb8890', fontSize: '0.25em'},
                    {background: elementBGColor, fontSize: '0.27em'},
                    {fontSize: '0.3em'}
                ];
                
                const kfEffect = new KeyframeEffect(element, keyFrames, {
                    duration: timeout,
                });

                return new Animation(kfEffect, document.timeline);
            }
        }

        const EditInput = function() {
            HTMLItems.call(this, 'input');
        };
        EditInput.prototype = {
            hidden(hidden) {
                if (hidden) {
                    this.isHidden = true;
                    this.element.setAttribute('type', 'hidden');
                } else {
                    this.isHidden = false;
                    this.element.setAttribute('type', 'text');
                }
            },
            value(value) {
                if (value)
                    this.element.value = value;
                else
                    return this.element.value;
            },
            blur() {
                this.element.blur();
            },
            focus() {
                this.element.focus();
            },
            select() {
                this.element.select();
            },
            onBlur(cb) {
                this.addEventListener('blur', cb);
            },
            onFocus(cb) {
                this.addEventListener('focus', cb);
            }
        }

        const Cell = function() {
            HTMLDraggableItems.call(this, 'div');
            this.setupCell();
        }
        Cell.prototype = {
            setupCell() {
                this.element.classList.add('cell');
            },
            setEditable(editable, onEdit, onValidate) {
                this.onEdit(onEdit, onValidate);
                this.element.classList.add('editable');
                this.editable;
            },
            isEditable() {
                return this.editable;
            },
            onEdit(onEdit, onValidate) {
                this.addEventListener('click', evt =>  this._edit(evt, onEdit, onValidate));
            },
            _edit(evt, onEdit, onValidate) {
                if (this.isEditing)
                    return;

                this.isEditing = true;
                this.input = new EditInput();
                this.hidden = new EditInput();
                this.input.hidden(false);
                this.hidden.hidden(true)
                this.input.onBlur(evt => this._validateBlur(evt, onValidate));
                this.input.addEventListener('keydown', evt =>  this._validateEnter(evt, onValidate));
                
                this.input.value(this.innerContent());
                this.hidden.value(this.innerContent());
                this.innerContent('');
                this.append(this.input, this.hidden);
                this.input.focus();
                this.input.select();
                onEdit(evt);
            },
            _validateBlur(evt, cb) {
                this._validate(evt, cb);
            },
            _validateEnter(evt, cb) {
                if (evt.key !== 'Enter')
                    return;
                this._validate(evt, cb);
            },
            _validate(evt, cb) {
                if (!this.isEditing)
                    return;
                let inputValue = this.input.value();

                if (inputValue != this.hidden.value()) {
                    cb(evt, inputValue);
                }
                this.innerContent(inputValue);
                this.isEditing = false;
            }

        };
        
        const SortableCell = function() {
            Cell.call(this);
            this.sorted = false;
            this.reversed = false;
            this.sortModes = {
                NONE: 0,
                ASC: 1,
                DESC: 2,
            }
            this._sortMode = this.sortModes.NONE;
        };
        SortableCell.prototype = {
            isReversed() {
                return this._sortMode == this.sortModes.DESC;
            },
            isSorted() {
                return this._sortMode > this.sortModes.NONE;
            },
            sort() {
                this._updateSortMode();
                this.eventsList.trigger('onSortedCell', this);
            },
            onSortedCell(cb, subscriber) {
                this.eventsList.onEventRegister({cb, subscriber}, 'onSortedCell');
            },
            _updateSortMode() {
                if (this._sortMode == this.sortModes.DESC)
                    this._sortMode = this.sortModes.NONE;
                else
                    this._sortMode++;
            },
        }

        const Row = function(head) {
            HTMLDraggableItems.call(this, 'div');
            this.cells = [];
            this._isHead = head;
            this.setupRow();
        }
        Row.prototype = {
            setupRow() {
                let className;
                if (this._isHead)
                    className = 'head';
                else
                    className = 'lonely';
                this.element.classList.add('row', className);
            },
            setGrid(grid) {
                this.grid = grid;
            },
            getGrid() {
                return this.grid;
            },
            addCell(cell) {
                cell.setParentItem(this);
                this.cells.push(cell);
            },
            isHead() {
                return this._isHead;
            },
            render() {
                if (!this.applied)
                    this.appendCells();
                return this.element;
            },
            appendCells() {
                this.applied = true;
                this.append(...this.cells);
            },
            getCells() {
                return this.cells;
            },
            getCellByIndex(cellIndx) {
                for (let i = 0; i < this.cells.length; ++i) {
                    let cell = this.cells[i];
                    if (cell.getIndex() == cellIndx)
                        return cell;
                }
            }
        };

        Object.setPrototypeOf(Row.prototype, HTMLDraggableItems.prototype);
        Object.setPrototypeOf(Cell.prototype, HTMLDraggableItems.prototype);
        Object.setPrototypeOf(EditInput.prototype, HTMLItems.prototype);
        Object.setPrototypeOf(SortableCell.prototype, Cell.prototype);
        const BaseColumn = function() {
            this.cells = [];
        };
        BaseColumn.prototype = {
            addCell(cell) {
                this.cells.push(cell);
            },
            getCells() {
                return this.cells;
            }
        }

        const IndexedColumn = function() {
            BaseColumn.call(this);
            this.columnIndex = 0;
            this.sortedCells = [];
            this.sortModes = {
                NONE: 0,
                ASC: 1,
                DESC: 2,
            }
            this._sortMode = this.sortModes.NONE;
        };
        IndexedColumn.prototype = {
            findCellsByIndex() {
                return this.cells.filter(cell => cell.getIndex() == this.columnIndex);
            },
            setIndex(index) {
                this.columnIndex = index;
            },
            getIndex() {
                return this.columnIndex;
            },
            getCells() {
                if (this.isSorted())
                    return this.sortedCells;
                return this.cells;
            },
            sort() {
                this._updateSortMode();
                if (!this.isSorted()) {
                    this.sortedCells = [];
                    return this.cells;
                }
                this.sortedCells = this.getSortedColumnCell();
                return this.sortedCells;
            },
            getSortedColumnCell() {
                const reversed = this.isReversed();
                return [...this.cells].sort((c1, c2) => {
                    if (c1.getParentItem().isHead())
                        return 0;
                    const cnt1 = c1.innerContent();
                    const cnt2 = c2.innerContent();
                    if (cnt1 > cnt2) return reversed ? -1 : 1;
                    if (cnt1 < cnt2) return reversed ? 1 : -1;
                    return 0;
                });
            },
            isReversed() {
                return this._sortMode == this.sortModes.DESC;
            },
            isSorted() {
                return this._sortMode > this.sortModes.NONE;
            },
            _updateSortMode() {
                if (this._sortMode == this.sortModes.DESC)
                    this._sortMode = this.sortModes.NONE;
                else
                    this._sortMode++;
            }
        }

        const BaseGrid = function(parentCnt) {
            this.rows = [];
            this.parentCnt = parentCnt;
        };
        BaseGrid.prototype = {
            getRows() {
                return this.rows;
            },
            setHead(row) {
                this.head = row;
            },
            addRow(row) {
                this.rows.push(row);
            },
            getParentCnt() {
                return this.parentCnt;
            },
            render() {
                clearElementInnerHTML(this.parentCnt);
                if (this.head)
                    this.parentCnt.append(this.head.render());
                this.rows.forEach(row => this.parentCnt.append(row.render()));
            }
        }

        const SortableGrid = function(parentCnt) {
            BaseGrid.call(this, parentCnt);
            this.indexedColumns = {};
            this.eventsList = new ListEvents();
        };
        SortableGrid.prototype = {
            addRow(row) {
                row.setGrid(this);
                row.onIndexUpdate(this.reindexGrid.bind(this), this);
                BaseGrid.prototype.addRow.call(this, row);
            },
            getColumnByIndex(colIndex) {
                if (!this.indexedColumns.hasOwnProperty(colIndex)) {
                    const column = new IndexedColumn();
                    for (let i = 0; i < this.rows.length; ++i) {
                        let row = this.rows[i];
                        if (this.head && row.isHead())
                            continue;
                        column.addCell(row.getCellByIndex(colIndex));
                    }
                    column.setIndex(colIndex);
                    this.indexedColumns[colIndex] = column;
                }
                
                return this.indexedColumns[colIndex];
            },
            sortGridByColumnIndex(colIndex) {
                const indexedColumn = this.getColumnByIndex(colIndex);
                this.rows = [];
                const sortedCells = indexedColumn.sort();
                
                for (let i = 0; i < sortedCells.length; ++i) {
                    this.rows.push(sortedCells[i].getParentItem());
                }
                this.eventsList.trigger('onSortedGrid', indexedColumn.isSorted(), indexedColumn.isReversed());
                this.render();
            },
            sortGridByColumnIndexV2(col) {
                col.sort();
                const colIndex = col.getIndex();
                const reversed = col.isReversed();
                const isSorted = col.isSorted();

                if (isSorted)
                    this._sortGrid(colIndex, reversed)

                this.eventsList.trigger('onSortedGrid', isSorted, reversed);
                this.render(isSorted);
            },
            onSortedGrid(cb, subscriber) {
                this.eventsList.onEventRegister({cb, subscriber}, 'onSortedGrid');
            },
            reindexGrid(newIdx, oldIdx, row) {
                this.rows.splice((oldIdx - 1), 1);
                
                for (let i = 0; i < this.rows.length; ++i) {
                    let r = this.rows[i],
                        idx = r.getIndex();
                    
                    if (oldIdx > newIdx && oldIdx > idx && idx >= newIdx) {
                        r.setIndex(idx + 1)
                    } else if (newIdx > oldIdx && newIdx >= idx && idx > oldIdx) {
                        r.setIndex(idx - 1)
                    }
                }
                
                this.rows.splice((newIdx - 1), 0, row);
                Object.keys(this.indexedColumns).forEach(colIndex => this.indexedColumns[colIndex] = this.getColumnByIndex(colIndex));
                this.render();
            },
            render(sorted) {
                clearElementInnerHTML(this.parentCnt);
                if (this.head)
                    this.parentCnt.append(this.head.render());
                let rows = this.rows;
                if (sorted)
                    rows = this.sortedRows;
                console.log('sorted', sorted, rows);
                rows.forEach(row => this.parentCnt.append(row.render()));
            },
            _sortGrid(colIndex, reversed) {
                this.sortedRows = [...this.rows].sort((row1, row2) => {
                    if (row1.isHead())
                        return 0;
                    const cnt1 = row1.getCellByIndex(colIndex).innerContent();
                    const cnt2 = row2.getCellByIndex(colIndex).innerContent();

                    if (cnt1 > cnt2) return reversed ? -1 : 1;
                    if (cnt1 < cnt2) return reversed ? 1 : -1;
                    return 0;
                });
            }
        }

        Object.setPrototypeOf(IndexedColumn.prototype, BaseColumn.prototype);
        Object.setPrototypeOf(SortableGrid.prototype, BaseGrid.prototype);

        const GridMaker = function(parentCnt, sortable) {
            this.rows = [];
            this.sortable = sortable;
            if (sortable) {
                this.grid = new SortableGrid(parentCnt);
                this.grid.onSortedGrid(this._onSortedGrid.bind(this));
            } else {
                this.grid = new BaseGrid(parentCnt);
            }

        };
        GridMaker.prototype = {
            setRows(rows) {
                for (let i = 0; i < rows.length; ++i) {
                    this.makeRow(rows[i]);
                }
            },
            setDraggable(draggable, byCell) {
                this.draggable = draggable;
                this.byCell = byCell;
            },
            isDraggable() {
                return this.draggable;
            },
            undragGrid() {
                this._unsetDraggableGrid();
            },
            makeRowIdx(cells, autoWidth, head, idx) {
                const row = new Row(head);
                const nbCells = cells.length;

                let percentage;
                if (autoWidth) {
                    let parentCnt = this.grid.getParentCnt();
                    percentage = (parentCnt.clientWidth / nbCells) / (parentCnt.clientWidth / 100);
                }

                for (let i = 0; i < nbCells; ++i) {
                    let c = cells[i];
                    let cell;
                    if (this.sortable) {
                        cell = new SortableCell();
                        cell.setIndex(i);
                        if (row.isHead() && !c.draggable) {
                            cell.addEventListener('click', this.grid.sortGridByColumnIndexV2.bind(this.grid, cell))
                        }
                    } else
                        cell = new Cell();
                    
                    if (c.hasOwnProperty('width'))
                        cell.width(c.width, c.unit);
                    else if (autoWidth)
                        cell.width(percentage, '%');

                    if (c.hasOwnProperty('height'))
                        cell.height(c.height, c.unit);
                    if (c.hasOwnProperty('editable') && c.editable)
                        cell.setEditable(c.editable, c.onEdit, c.onValidate);
                    if (c.hasOwnProperty('draggable') && this.byCell && !row.isHead()) {
                        cell.setDraggable(c.draggable);
                        cell.onDragged(c.onDragged);
                        cell.onDropped(c.onDropped);
                    }
                    
                    cell.innerContent(c.content);
                    row.addCell(cell);
                }

                if (!this.byCell && !row.isHead())
                    row.setDraggable(this.draggable);
                
                if (this.sortable)
                    row.setIndex(idx);
                
                if (row.isHead())
                    this.grid.setHead(row);
                else
                    this.grid.addRow(row);
            },
            render() {
                this.grid.render();
                if (this.isDraggable())
                    this._setDraggableGrid();
            },
            getDraggableRows() {
                return this.grid.getRows().filter(r => r.isDraggable());
            },
            getDraggableCells() {
                const cells = [];
                const rows = this.grid.getRows();
                for (let i = 0; i < rows.length; ++i) {
                    let row = rows[i];
                    cells.push(...row.getCells().filter(c => c.isDraggable()))
                }
                return cells;
            },
            _onSortedGrid(isSorted) {
                if (isSorted) {
                    this._unsetDraggableGrid();
                } else {
                    this._setDraggableGrid();
                }
            },
            _setDraggableGrid() {
                if (!this.dragitManager)
                    this.dragitManager = new DragitManager();
                if (!this.byCell)
                    this.dragitManager.activate(this.getDraggableRows());
                else
                    this.dragitManager.activate(this.getDraggableCells(), true);
            },
            _unsetDraggableGrid() {
                if (!this.dragitManager)
                    return;
                this.dragitManager.deactivate();
            }
        }

        const gridMaker = new GridMaker(document.getElementById('content'), true);

        const nbRows = 25;
        const nbCells = 11;
        const letters = ["1", '2', '3', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm'];
        gridMaker.setDraggable(true, true);

        for (let i = 0; i < nbRows; ++i) {
            let cells = [];
            for (let y = 0; y < nbCells; ++y) {
                cells.push({
                    content: i == 0 && y == nbCells - 1 ? 'Drag them!!' : y == nbCells - 1 ? 'Drag me!!' : generateLoremText(1, 6),
                    unit: 'px',
                    editable: y < nbCells - 1 && i > 0 && y % 2 != 0,
                    onEdit: (evt) => {
                        console.log('editing!', evt);
                    },
                    onValidate: (evt, value) => {
                        console.log('validate value', value);
                    },
                    draggable: y == nbCells - 1 && i > 0,
                    onDragged: (evt) => {
                        evt.detail.HTMLItem.innerContent('Drop me!!');
                    },
                    onDropped: (evt) => {
                        evt.detail.HTMLItem.innerContent('Drag me!!');
                    }
                });
            }
            gridMaker.makeRowIdx(cells, true, i == 0, i);
        }

        gridMaker.render();
    })(this, document);
    </script>
</body>
