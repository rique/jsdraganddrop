<!DOCTYPE html>
<html>
<head>
    <title>Dragit!</title>
    <style>
    @keyframes stretchdown {
        from {
            padding-bottom: 0px;
            border-bottom: 0px;
        }
        to {
            padding-bottom: 32px;
            border-bottom: 1px solid #ff4f4f;
        }
    }

    * {
        margin: 0;
        padding: 0;
    }

    html {
        height: 100%;
    }

    body {
        background: #0f0f0f;
        height: 100%;
    }

    #content {
        width: 90%;
        height: 90%;
        background: #f0f0f0;
        margin: auto;
        position: relative;
        border-left: 1px solid #0f0f0f;
        border-right: 1px solid #0f0f0f;
        user-select: none;
        overflow: auto;
    }

    .row {
        width: 100%;
        border-bottom: 1px solid #0f0f0f;
        background: #f7f8f8;
        font-size: 16px;
        height: 2.6%;
        color: #252525;
    }

    .row.head {
        font-weight: bold;
        position: sticky;
        top: 0;
        left: 0;
    }

    .row:has(.empty), .row.hovered {
        animation: 70ms 1 forwards stretchdown
    }

    .row:first-child {
        border-top: 1px solid #0f0f0f;
    }

    .row.lonely:nth-child(even) {
        background: #bbe3fc;
    }

    .row.lonely:nth-child(even):hover {
        background: #a5c9e1;
    }

    .row:nth-child(odd):hover {
        background: #eaeaea;
    }

    .empty {
        height: 0px;
        display: block;
        width: 100%;
        background:#f7f8f8;
        border-top: 1px solid #0f0f0f;
    }

    .row.dragged {
        border: 1px dashed #0f0f0f;
        font-size: 12px;
        height: 2.3%;
        filter: drop-shadow(0 0 8px rgba(85, 85, 85, 0.5));
        filter: opacity(78%);
    }

    .cell {
        border-right: 1px solid #0f0f0f;
        display: inline-block;
        vertical-align: top;
        text-align: center;
        padding: 6px 0;
        box-sizing: border-box;
        height: 100%;
    }

    .draggable {
        cursor: move;
    }

    .row.hovered .cell {
        border-bottom: 1px solid #ff4f4f;
    }

    .head .cell, .cell.editable {
        cursor: default;
    }

    .cell:last-child {
        border: 0;
    }

    </style>
</head>
<body>
    <div id="content">
    </div>

    <script>
    (function(window, document, undefined) {

        const randomStr = (length) => {
            let result = '',
                characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-',
                charactersLength = characters.length;
            for (let i = 0; i < length; ++i) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        }

        const getOffsetLeft = (elem) => {
            let offset = 0;
            while (elem.parentElement) {
                    offset += elem.parentElement.offsetLeft;
                    elem = elem.parentElement;
            }
            return offset;
        }

        getLastParent = (elem) => {
            while(elem.parentElement && elem.parentElement != document.body) {
                elem = elem.parentElement;
            }

            return elem;
        }

        const getButton = (key) => {
            const buttons = {
                0: 'uninitialized',
                1: 'leftClick',
                2: 'rightClick',
                4: 'middle',
                8: 'back',
                16: 'forward'
            };
            if (buttons.hasOwnProperty(key))
                return buttons[key];
            return 'unknown';
        };

        const getCursor = (evt) => {
            return {
                X: evt.clientX,
                Y: evt.clientY,
                buttons: getButton(evt.buttons)
            }
        }

        const OneEvent = function(callback) {
            this.callback = callback;
        }
        OneEvent.prototype = {
            trigger(args) {
                this.callback(...args);
            }
        };

        const ListEvents = function() {
            this._eventsRegistered = [];
        };
        ListEvents.prototype = {
            onEventRegister({cb, subscriber}, eventKey) {
                this._eventsRegistered.push({'eventKey': eventKey, 'subscriber': subscriber,  'event': new OneEvent(cb)});
            },
            unsubscribeEVent({eventKey, subscriber}) {
                const subInedx = this._eventsRegistered.findIndex(evt => evt.subscriber == subscriber && evt.eventKey == eventKey);
                if (typeof subInedx === 'undefined')
                    return;
                this._eventsRegistered.splice(subInedx, 1);
            },
            trigger(eventKey, ...args) {
                args = args || [];
                this._onEventTrigger(eventKey, args);
            },
            _onEventTrigger(eventKey, args) {
                const evts = this._eventsRegistered.filter(evt => evt.eventKey == eventKey);
                if (evts.length == 0)
                    return;
                for (let i = 0; i < evts.length; ++i) {
                    evts[i].event.trigger(args);
                }
            },
            _checkEventKey(eventKey) {
                const indx = this._eventsRegistered.findIndex(evt => evt.eventKey == eventKey);
                if (indx != -1) {
                    console.error(`Event ${eventKey} already register`);
                    throw `Event ${eventKey} already register`;
                }
            },
        };

        const DragmeMover = function(dragme) {
            this.dragme = dragme;
        }
        DragmeMover.prototype = {
            init(seekParent) {
                return this.dragme.init(seekParent);
            },
            moveTo(x, y, seekParent) {
                if (this.prevX && this.prevY) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX),
                        dragY = this.dragme.offsetTop() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.setLeftTop.bind(this.dragme, dragX, dragY));
                }

                this.prevX = x;
                this.prevY = y;
            },
            moveXTo(x) {
                if (this.prevX) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX);
                    requestAnimationFrame(this.dragme.left.bind(this.dragme, dragX, 'px'));
                }

                this.prevX = x;
            },
            moveYTo(y) {
                if (this.prevY) {
                    let dragY = this.dragme.offsetLeft() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.top.bind(this.dragme, dragY, 'px'));
                }

                this.prevY = y;
            },
            done() {
                this.prevX = undefined;
                this.prevY = undefined;
                this.dragme.reset();
            },
            getDragme() {
                return this.dragme;
            }
        };

        const DragIt = function(dragMover) {
            this.dragMover = dragMover;
            this.pressed = false;
        }
        DragIt.prototype = {
            setDragMover(dragMover) {
                this.dragMover = dragMover;
            },
            getDragMover() {
                return this.dragMover;
            },
            getDragme(seekParent) {
                return this.dragMover.getDragme();
            },
            setDragmeSeekParent() {
                this.dragMover.getDragme().setSeekParent();
            },
            unsetDragmeSeekParent() {
                this.dragMover.getDragme().unsetSeekParent();
            },
            dragit(cursor, seekParent) {
                if (cursor.buttons != 'leftClick')
                    return;

                if (!this._isInit)
                    this._init(seekParent);
                this.pressed = true;

                this.getDragme().dispatchEvent('dragged');

                this.dragMover.moveTo(cursor.X, cursor.Y);
            },
            dragmove(cursor, seekParent) {
                if (this.pressed)
                    this.dragit(cursor, seekParent);
            },
            dragstop(cursor) {
                if (!this.pressed)
                    return;

                this.getDragme().dispatchEvent('dropped');

                this._finish();
            },
            insertDragAfter(drag) {
                this.getDragme().insertDragAfter(drag.getDragme());
            },
            toggleHovered(hovered) {
               this.getDragme().toggleHovered(hovered)
            },
            _init(seekParent) {
                this._isInit = this.dragMover.init(seekParent);
            },
            _finish() {
                this.pressed = false;
                this._isInit = false;
                this.dragMover.done();
                if (this.onFinish && typeof this.onFinish === 'function')
                    this.onFinish(this);
            }
        }

        const DragitManager = function(drags) {
            this.drags = drags || [];
            this.seekParent = false;
        }
        DragitManager.prototype = {
            activate(elementsArray, seekParent) {
                this.seekParent = seekParent;
                this._bindedDragit = this._dragit.bind(this);
                this._bindedDragmove = this._dragmove.bind(this);
                this._bindedDragstop = this._dragstop.bind(this);

                document.addEventListener('mousedown', this._bindedDragit);
                document.addEventListener('mousemove', this._bindedDragmove);
                document.addEventListener('mouseup', this._bindedDragstop);

                if (elementsArray)
                    this.setDrags(elementsArray);

                this.activated = true;
            },
            setDrags(elementsArray) {
                for (let i = 0; i < elementsArray.length; ++i) {
                    this.drags.push(new DragIt(new DragmeMover(elementsArray[i])));
                }
            },
            deactivate() {
                if (!this.activated)
                    return;

                document.removeEventListener('mousedown', this._bindedDragit);
                document.removeEventListener('mousemove', this._bindedDragmove);
                document.removeEventListener('mouseup', this._bindedDragstop);

                this.activated = false;
            },
            _dragit(evt) {
                this._findCursorHoveredDrag(getCursor(evt), (drag, cursor) => {
                    drag.dragit(cursor, this.seekParent);
                    this.currentDrag = drag;
                });
            },
            _dragmove(evt) {
                if (!this.currentDrag)
                    return;

                const drag = this._findHoveredDrag(this.currentDrag);

                if (drag) {
                    if (this.hoveredDrag) {
                        if (this.seekParent)
                            this.hoveredDrag.setDragmeSeekParent();
                        this.hoveredDrag.getDragme().toggleHovered();
                        if (this.seekParent)
                            this.hoveredDrag.unsetDragmeSeekParent();
                    }
                    if (this.seekParent)
                        drag.setDragmeSeekParent();
                    drag.getDragme().toggleHovered();
                    if (this.seekParent)
                        drag.unsetDragmeSeekParent();
                    this.hoveredDrag = drag;
                }

                this.currentDrag.dragmove(getCursor(evt), this.seekParent);
            },
            _dragstop(evt) {
                if (!this.currentDrag)
                    return;

                const drag = this._findHoveredDrag(this.currentDrag);

                if (this.hoveredDrag) {
                     if (this.seekParent)
                        this.hoveredDrag.setDragmeSeekParent();
                    this.hoveredDrag.getDragme().toggleHovered();
                    if (this.seekParent)
                        this.hoveredDrag.unsetDragmeSeekParent();
                }
                if (drag) {
                    if (this.seekParent)
                        drag.setDragmeSeekParent();
                    this.currentDrag.insertDragAfter(drag);
                    if (this.seekParent)
                        drag.unsetDragmeSeekParent();
                }

                this.currentDrag.dragstop(getCursor(evt), this.seekParent);
                this.currentDrag = undefined;
                this.hoveredDrag = undefined;
            },
            _divContainsDrag(drag, div) {
                const dragOffsetLeft = drag.offsetLeft() + (drag.offsetWidth() / 2);
                const dragOffsetTop = drag.offsetTop() + (drag.offsetHeight() / 2);

                return (dragOffsetLeft >= div.offsetLeft() && dragOffsetLeft < div.offsetRight()) &&
                    (dragOffsetTop >= div.offsetTop() && dragOffsetTop < div.offsetBottom());
            },
            _TargetContainsCursor(cursor, target) {
                const X = cursor.X + target.scrollLeft();
                const Y = cursor.Y + target.scrollTop();
                return X > target.offsetLeft(true) && X < target.offsetRight(true) &&
                    Y > target.offsetTop() && Y < target.offsetBottom();
            },
            _findCursorHoveredDrag(cursor, cb) {
                for (let i = 0; i < this.drags.length; ++i) {
                    let drag = this.drags[i];
                    if (this._TargetContainsCursor(cursor, drag.getDragme())) {
                        if (typeof cb === 'function')
                            cb(drag, cursor);
                        break;
                    }
                }
            },
            _findHoveredDrag(drag) {
                let foundDrag;
                for (let i = 0; i < this.drags.length; ++i) {
                    let dr = this.drags[i];
                    if (dr.getDragme() == drag.getDragme())
                        continue;
                    if (this.seekParent)
                        dr.setDragmeSeekParent();
                    if (this._divContainsDrag(drag.getDragme(), dr.getDragme())) {
                        if (this.seekParent)
                            dr.unsetDragmeSeekParent();
                        foundDrag = dr;
                        break;
                    }
                    if (this.seekParent)
                        dr.unsetDragmeSeekParent();
                }

                return foundDrag;
            }
        };

        const HTMLDraggableItems = function(elementName) {
            this.element = document.createElement(elementName);
            this._setupEvents();
        }
        HTMLDraggableItems.prototype = {
            super() {
                return HTMLDraggableItems;
            },
            render(getReal) {
                if (getReal && this.seekParent) {
                    return this.element.querySelector('.draggable');
                }
                return this.element;
            },
            width(width, unit) {
                if (typeof width === 'number')
                    this.element.style.width = `${width}${unit}`;
                else
                    return this.element.style.width;
            },
            height(height, unit) {
                if (typeof height === 'number')
                    this.element.style.height = `${height}${unit}`;
                else
                    return this.element.style.height;
            },
            left(left, unit) {
                if (typeof left === 'number')
                    this.element.style.left = `${left}${unit}`;
                else
                    return this.element.style.left;
            },
            top(top, unit) {
                if (typeof top === 'number')
                    this.element.style.top = `${top}${unit}`;
                else
                    return this.element.style.top;
            },
            offsetTop() {
                return this.element.offsetTop;
            },
            offsetLeft(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.element);
                }
                return this.element.offsetLeft + margin;
            },
            offsetRight(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.element);
                }
                return this.element.offsetLeft + this.element.offsetWidth + margin;
            },
            offsetBottom() {
                return this.element.offsetTop + this.element.offsetHeight;
            },
            offsetWidth() {
                return this.element.offsetWidth;
            },
            offsetHeight() {
                return this.element.offsetHeight;
            },
            setLeftTop(left, top) {
                this.element.style.left = `${left}px`;
                this.element.style.top = `${top}px`;
            },
            scrollTop() {
                const parentElem = getLastParent(this.element);
                return parentElem.scrollTop;
            },
            scrollLeft() {
                const parentElem = getLastParent(this.element);
                return parentElem.scrollLeft;
            },
            innerContent(content) {
               this.render(true).innerHTML = content;
            },
            css(style, replace) {
                style = style || {};
                if (!replace)
                    style = {...this.element.style, ...style};

                Object.keys(style).forEach(k => this.element.style[k] = style[k]);
            },
            setSeekParent() {
                this.seekParent = true;
                this.element =  this.element.parentElement;
            },
            unsetSeekParent() {
                this.seekParent = false;
                this.element = this.element.querySelector('.draggable');
            },
            toggleHovered() {
                this.element.classList.toggle('hovered')
            },
            insertDragAfter(thisInstance) {
                thisInstance.element.insertAdjacentElement('afterend', this.render());
            },
            setDraggable(draggable) {
                if (draggable)
                    this.element.classList.add('draggable');
                else
                    this.element.classList.remove('draggable');
                this.draggable = draggable;
            },
            onDragged(cb) {
                this.element.addEventListener('dragged', cb);
            },
            onDropped(cb) {
                this.element.addEventListener('dropped', cb);
            },
            isDraggable() {
                return this.draggable;
            },
            init(seekParent) {
                if (!this.element)
                    return false;

                if (seekParent)
                    this.setSeekParent();

                this.css({
                    position: 'absolute',
                    left: `${this.offsetLeft()}px`,
                    top: `${this.offsetTop()}px`,
                    zIndex: 100,
                });

                this.element.classList.add('dragged');

                return true;
            },
            reset() {
                this.css({
                    position: 'static',
                });

                this.element.classList.remove('dragged');

                if (this.seekParent)
                    this.unsetSeekParent();
            },
            dispatchEvent(evtName) {
                switch(evtName) {
                    case 'dragged':
                        this.render(true).dispatchEvent(this.onDraggedEvt);
                        break;
                    case 'dropped':
                        this.render(true).dispatchEvent(this.onDroppedEvt);
                        break;
                    default:
                        console.error(`Unknown event name ${evtName}`);
                        break;
                }
            },
            _setupEvents() {
                this.onDraggedEvt = new CustomEvent('dragged', {detail: {HTMLItem: this}});
                this.onDroppedEvt = new CustomEvent('dropped', {detail: {HTMLItem: this}});
            }
        }

        const Cell = function() {
            this.super().call(this, 'div');
            this.setupCell();
            this._eventManager = new ListEvents();
        }
        Cell.prototype = {
            setupCell() {
                this.element.classList.add('cell');
            },
            setEditable(editable, onEdit) {
                this.editable = editable;
                this.element.addEventListener('click', onEdit);
            }
        };

        const Row = function(head) {
            this.super().call(this, 'div');
            this.cells = [];
            this._isHead = head;
            this.setupRow();
        }
        Row.prototype = {
            setupRow() {
                let className;
                if (this._isHead)
                    className = 'head';
                else
                    className = 'lonely';
                this.element.classList.add('row', className);
            },
            addCell(cell) {
                this.cells.push(cell);
            },
            isHead() {
                return this._isHead;
            },
            render() {
                if (!this.applied)
                    this.appendCells();
                return this.element;
            },
            appendCells() {
                this.applied = true;
                this.cells.forEach(cell => this.element.append(cell.render()));
            },
            getCells() {
                return this.cells;
            }
        };

        Object.setPrototypeOf(Cell.prototype, HTMLDraggableItems.prototype);
        Object.setPrototypeOf(Row.prototype, HTMLDraggableItems.prototype);

        const GridMaker = function(parentCnt) {
            this.parentCnt = parentCnt;
            this.rows = [];
        }
        GridMaker.prototype = {
            setRows(rows) {
                for (let i = 0; i < rows.length; ++i) {
                    this.makeRow(rows[i])
                }
            },
            setDraggable(draggable, byCell) {
                this.draggable = draggable;
                this.byCell = byCell;
            },
            isDraggable() {
                return this.draggable;
            },
            undragGrid() {
                this._unsetDraggableGrid();
            },
            makeRow(cells, autoWidth, head) {
                const row = new Row(head);
                const nbCells = cells.length;
                let cellWidth;
                if (autoWidth) {
                    cellWidth = (this.parentCnt.clientWidth / nbCells);
                }

                for (let i = 0; i < nbCells; ++i) {
                    let c = cells[i];
                    let cell = new Cell();

                    if (c.hasOwnProperty('width'))
                        cell.width(c.width, c.unit);
                    else if (autoWidth)
                        cell.width(cellWidth, 'px');

                    if (c.hasOwnProperty('height'))
                        cell.height(c.height, c.unit);
                    if (c.hasOwnProperty('editable') && c.editable)
                        cell.setEditable(c.editable, c.onEdit);
                    if (c.hasOwnProperty('draggit') && this.byCell && !row.isHead()) {
                        cell.setDraggable(c.draggit);
                        cell.onDragged(c.onDragged);
                        cell.onDropped(c.onDropped);
                    }

                    cell.innerContent(c.content);
                    row.addCell(cell);
                }

                if (!this.byCell && !row.isHead())
                    row.setDraggable(this.draggable);
                this.rows.push(row);
            },
            render() {
                this.rows.forEach(row => this.parentCnt.append(row.render()));
                if (this.isDraggable())
                    this._setDraggableGrid();
            },
            getDraggableRows() {
                return this.rows.filter(r => r.isDraggable());
            },
            getDraggableCells() {
                const cells = [];
                for (let i = 0; i < this.rows.length; ++i) {
                    let row = this.rows[i];
                    cells.push(...row.getCells().filter(c => c.isDraggable()))
                }
                return cells;
            },
            _setDraggableGrid() {
                if (!this.dragitManager)
                    this.dragitManager = new DragitManager();
                if (!this.byCell)
                    this.dragitManager.activate(this.getDraggableRows());
                else
                    this.dragitManager.activate(this.getDraggableCells(), true);
            },
            _unsetDraggableGrid() {
                if (!this.dragitManager)
                    return;
                this.dragitManager.deactivate();
            }
        }

        const gridMaker = new GridMaker(document.getElementById('content'));

        const nbRows = 260;
        const nbCells = 9;

        gridMaker.setDraggable(true, true);

        for (let i = 0; i < nbRows; ++i) {
            let cells = [];
            for (let y = 0; y < nbCells; ++y) {
                cells.push({
                    content: y == nbCells - 1 ? 'Dragme!!' : randomStr(6),
                    unit: 'px',
                    editable: false,
                    onEdit: (value) => {
                        console.log('edit value', value);
                    },
                    draggit: y == nbCells - 1 && i > 0,
                    onDragged: (evt) => {
                        evt.detail.HTMLItem.innerContent('Dropme!!');
                    },
                    onDropped: (evt) => {
                        evt.detail.HTMLItem.innerContent('Dragme!!');
                    }
                });
            }
            gridMaker.makeRow(cells, true, i == 0);
        }

        gridMaker.render();
    })(this, document);
    </script>
</body>
