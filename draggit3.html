<!DOCTYPE html>
<html>
<head>
    <title>Dragit!</title>
    <style>
    * {
        margin: 0;
        padding: 0;
    }

    html {
        height: 100%;
    }

    body {
        background: #0f0f0f;
        height: 100%;
    }

    #content {
        width: 90%;
        height: 90%;
        background: #f0f0f0;
        margin: auto;
        position: relative;
        border-left: 1px solid #0f0f0f;
        border-right: 1px solid #0f0f0f;
        user-select: none;
        overflow: auto;
    }

    .row {
        width: 100%;
        border-bottom: 1px solid #0f0f0f;
        background: #f7f8f8;
        font-size: 16px;
        height: 2.6%;
        color: #252525;
    }

    .row.head {
        font-weight: bold;
    }

    .row:has(.empty), .row.hovered {
        border-bottom: 1px solid #ff4f4f;
        padding-bottom: 32px;
    }

    .row:first-child {
        border-top: 1px solid #0f0f0f;
    }

    .row.lonely:nth-child(even) {
        background: #bbe3fc;
    }

    .row.lonely:nth-child(even):hover {
        background: #a5c9e1;
    }

    .row:nth-child(odd):hover {
        background: #eaeaea;
    }

    .empty {
        height: 0px;
        display: block;
        width: 100%;
        background:#f7f8f8;
        border-top: 1px solid #0f0f0f;
    }

    .row.dragged {
        border: 1px dashed #0f0f0f;
        font-size: 12px;
        height: 2.3%;
        filter: drop-shadow(0 0 8px rgba(85, 85, 85, 0.5));
    }

    .cell {
        border-right: 1px solid #0f0f0f;
        display: inline-block;
        vertical-align: top;
        text-align: center;
        padding: 6px 0;
        box-sizing: border-box;
        height: 100%;
    }

    .draggable {
        cursor: move;
    }

    .row.hovered .cell {
        border-bottom: 1px solid #ff4f4f;
    }

    .head .cell, .cell.editable {
        cursor: default;
    }

    .cell:last-child {
        border: 0;
    }

    </style>
</head>
<body>
    <div id="content">
    </div>

    <script>
    (function(window, document, undefined) {

        const makeid = (length) => {
            var result           = '';
            var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-';
            var charactersLength = characters.length;
            for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        }

        const getOffsetLeft = (elem) => {
            let offset = 0;
            while (elem.parentElement) {
                    offset += elem.parentElement.offsetLeft;
                    elem = elem.parentElement;
            }
            return offset;
        }

        const getButton = (key) => {
            const buttons = {
                0: 'uninitialized',
                1: 'leftClick',
                2: 'rightClick',
                4: 'middle',
                8: 'back',
                16: 'forward'
            };
            if (buttons.hasOwnProperty(key))
                return buttons[key];
            return 'unknown';
        };

        const getCursor = (evt) => {
            return {
                X: evt.clientX,
                Y: evt.clientY,
                buttons: getButton(evt.buttons)
            }
        }

        const OneEvent = function(callback) {
            this.callback = callback;
        }
        OneEvent.prototype = {
            trigger(args) {
                this.callback(...args);
            }
        };

        const ListEvents = function() {
            this._eventsRegistered = [];
        };
        ListEvents.prototype = {
            onEventRegister({cb, subscriber}, eventKey) {
                this._eventsRegistered.push({'eventKey': eventKey, 'subscriber': subscriber,  'event': new OneEvent(cb)});
            },
            unsubscribeEVent({eventKey, subscriber}) {
                const subInedx = this._eventsRegistered.findIndex(evt => evt.subscriber == subscriber && evt.eventKey == eventKey);
                if (typeof subInedx === 'undefined')
                    return;
                this._eventsRegistered.splice(subInedx, 1);
            },
            trigger(eventKey, ...args) {
                args = args || [];
                this._onEventTrigger(eventKey, args);
            },
            _onEventTrigger(eventKey, args) {
                const evts = this._eventsRegistered.filter(evt => evt.eventKey == eventKey);
                if (evts.length == 0)
                    return;
                for (let i = 0; i < evts.length; ++i) {
                    evts[i].event.trigger(args);
                }
            },
            _checkEventKey(eventKey) {
                const indx = this._eventsRegistered.findIndex(evt => evt.eventKey == eventKey);
                if (indx != -1) {
                    console.error(`Event ${eventKey} already register`);
                    throw `Event ${eventKey} already register`;
                }
            },
        };

        const DragmeMover = function(dragme) {
            this.dragme = dragme;
        }
        DragmeMover.prototype = {
            init(seekParent) {
                return this.dragme.init(seekParent);
            },
            moveTo(x, y, seekParent) {
                if (this.prevX && this.prevY) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX),
                        dragY = this.dragme.offsetTop() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.setLeftTop.bind(this.dragme, dragX, dragY));
                }

                this.prevX = x;
                this.prevY = y;
            },
            moveXTo(x) {
                if (this.prevX) {
                    let dragX = this.dragme.offsetLeft() + (x - this.prevX);
                    requestAnimationFrame(this.dragme.setLeft.bind(this.dragme, dragX));
                }

                this.prevX = x;
            },
            moveYTo(y) {
                if (this.prevY) {
                    let dragY = this.dragme.offsetLeft() + (y - this.prevY);
                    requestAnimationFrame(this.dragme.setTop.bind(this.dragme, dragY));
                }

                this.prevY = y;
            },
            done(seekParent) {
                this.prevX = undefined;
                this.prevY = undefined;
                this.dragme.reset(seekParent);
            },
            getDragme() {
                return this.dragme;
            }
        };

        const Dragme = function(dragElem) {
            this.dragElem = dragElem;
        }
        Dragme.prototype = {
            getDragElem(getReal, seekParent) {
                if (getReal && seekParent)
                    return this.dragElem.querySelector('.draggable');
                return this.dragElem;
            },
            init(seekParent) {
                if (!this.dragElem)
                    return false;
                if (seekParent)
                    this.setSeekParent();
                this.dragElem.style.position = 'absolute';
                this.dragElem.style.left = `${this.offsetLeft()}px`;
                this.dragElem.style.top = `${this.offsetTop()}px`;
                this.dragElem.style.zIndex= 100;
                this.dragElem.classList.add('dragged');

                return true;
            },
            reset(seekParent) {
                if (this.emptyRow)
                    this._removeEmptyRow();
                this.dragElem.style = {};
                this.dragElem.classList.remove('dragged');
                if (seekParent)
                    this.unsetSeekParent();
            },
            offsetTop() {
                return this.dragElem.offsetTop;
            },
            offsetLeft(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.dragElem);
                }
                return this.dragElem.offsetLeft + margin;
            },
            offsetRight(doMargin) {
                let margin = 0;
                if (doMargin) {
                    margin = getOffsetLeft(this.dragElem);
                }
                return this.dragElem.offsetLeft + this.dragElem.offsetWidth + margin;
            },
            offsetBottom() {
                return this.dragElem.offsetTop + this.dragElem.offsetHeight;
            },
            offsetWidth() {
                return this.dragElem.offsetWidth;
            },
            offsetHeight() {
                return this.dragElem.offsetHeight;
            },
            left() {
                return this.dragElem.style.left;
            },
            top() {
                return this.dragElem.style.top;
            },
            setLeft(left) {
                this.dragElem.style.left = `${left}px`;
            },
            setTop(top) {
                this.dragElem.style.top = `${top}px`;
            },
            setLeftTop(left, top) {
                this.dragElem.style.left = `${left}px`;
                this.dragElem.style.top = `${top}px`;
            },
            setSeekParent() {
                this.dragElem =  this.dragElem.parentNode;
            },
            unsetSeekParent() {
                this.dragElem = this.dragElem.querySelector('.draggable');
            },
            setHovered() {
                this.dragElem.classList.toggle('hovered')
            },
            insertDragAfter(drag) {
                drag.getDragElem().insertAdjacentElement('afterend', this.dragElem);
            },
            insertEmptyRowAfter() {
                if (!this.emptyRow)
                    this._setUpEmptyRow();

                this.dragElem.append(this.emptyRow);
            },
            removeEmptyRowAFter() {
                if (!this.emptyRow)
                    return;
                this.emptyRow.remove();
                this.emptyRow = undefined;
            },
            _setUpEmptyRow() {
                this.emptyRow = document.createElement('div');
                this.emptyRow.className = 'empty';
            }
        }

        const Dragit = function(dragMover) {
            this.dragMover = dragMover;
            this.pressed = false;
        }
        Dragit.prototype = {
            setDragMover(dragMover) {
                this.dragMover = dragMover;
            },
            getDragMover() {
                return this.dragMover;
            },
            getDragme(seekParent) {
                return this.dragMover.getDragme();
            },
            setDragmeSeekParent() {
                this.dragMover.getDragme().setSeekParent();
            },
            unsetDragmeSeekParent() {
                this.dragMover.getDragme().unsetSeekParent();
            },
            dragit(cursor, seekParent) {
                if (cursor.buttons != 'leftClick')
                    return;

                if (!this._isInit)
                    this._init(seekParent);
                this.pressed = true;

                const dragmeEl = this.getDragme().getDragElem(true, seekParent);

                if (typeof dragmeEl.onDragged === 'function')
                    dragmeEl.onDragged();
                //dragElemt.dispatchEvent(this.onDraggedEvt);

                this.dragMover.moveTo(cursor.X, cursor.Y);
            },
            dragmove(cursor, seekParent) {
                if (this.pressed)
                    this.dragit(cursor, seekParent);
            },
            dragstop(cursor, seekParent) {
                if (!this.pressed)
                    return;

                const dragmeEl = this.getDragme().getDragElem(true, seekParent);

                if (typeof dragmeEl.onDropped === 'function')
                    dragmeEl.onDropped();

                //dragmeEl.dispatchEvent(this.onDroppedEvt);

                this._finish(seekParent);
            },
            insertDragAfter(drag) {
                this.getDragme().insertDragAfter(drag.getDragme());
            },
            setHovered(hovered) {
               this.getDragme().setHovered(hovered)
            },
            _init(seekParent) {
                this._isInit = this.dragMover.init(seekParent);
            },
            _finish(seekParent) {
                this.pressed = false;
                this._isInit = false;
                this.dragMover.done(seekParent);
                if (this.onFinish && typeof this.onFinish === 'function')
                    this.onFinish(this);
            }
        }

        const DragitManager = function(drags) {
            this.drags = drags || [];
            this.seekParent = false;
        }
        DragitManager.prototype = {
            activate(elementsArray, seekParent) {
                this.seekParent = seekParent;
                this._bindedDragit = this._dragit.bind(this);
                this._bindedDragmove = this._dragmove.bind(this);
                this._bindedDragstop = this._dragstop.bind(this);

                document.addEventListener('mousedown', this._bindedDragit);
                document.addEventListener('mousemove', this._bindedDragmove);
                document.addEventListener('mouseup', this._bindedDragstop);

                if (elementsArray)
                    this.setDrags(elementsArray);

                this.activated = true;
            },
            setDrags(elementsArray) {
                for (let i = 0; i < elementsArray.length; ++i) {
                    this.drags.push(new Dragit(new DragmeMover(new Dragme(elementsArray[i]))));
                }
                // elementsArray.forEach(el => this.drags.push(new Dragit(new DragmeMover(new Dragme(el)))));
            },
            deactivate() {
                if (!this.activated)
                    return;

                document.removeEventListener('mousedown', this._bindedDragit);
                document.removeEventListener('mousemove', this._bindedDragmove);
                document.removeEventListener('mouseup', this._bindedDragstop);

                this.activated = false;
            },
            _dragit(evt) {
                this._findCursorHoveredDrag(getCursor(evt), (drag, cursor) => {
                    drag.dragit(cursor, this.seekParent);
                    this.currentDrag = drag;
                });
            },
            _dragmove(evt) {
                if (!this.currentDrag)
                    return;

                const drag = this._findHoveredDrag(this.currentDrag);

                if (drag) {
                    if (this.hoveredDrag) {
                        if (this.seekParent)
                            this.hoveredDrag.setDragmeSeekParent();
                        this.hoveredDrag.getDragme().setHovered();
                        if (this.seekParent)
                            this.hoveredDrag.unsetDragmeSeekParent();
                    }
                    if (this.seekParent)
                        drag.setDragmeSeekParent();
                    drag.getDragme().setHovered();
                    if (this.seekParent)
                        drag.unsetDragmeSeekParent();
                    this.hoveredDrag = drag;
                }

                this.currentDrag.dragmove(getCursor(evt), this.seekParent);
            },
            _dragstop(evt) {
                if (!this.currentDrag)
                    return;

                const drag = this._findHoveredDrag(this.currentDrag);

                if (this.hoveredDrag) {
                     if (this.seekParent)
                        this.hoveredDrag.setDragmeSeekParent();
                    this.hoveredDrag.getDragme().setHovered();
                    if (this.seekParent)
                        this.hoveredDrag.unsetDragmeSeekParent();
                }
                if (drag) {
                    if (this.seekParent)
                        drag.setDragmeSeekParent();
                    this.currentDrag.insertDragAfter(drag);
                    if (this.seekParent)
                        drag.unsetDragmeSeekParent();
                }

                this.currentDrag.dragstop(getCursor(evt), this.seekParent);
                this.currentDrag = undefined;
                this.hoveredDrag = undefined;
            },
            _divContainsDrag(drag, div) {
                const divOffsetRight = div.offsetLeft() + div.offsetWidth();
                const divOffsetBottom = div.offsetTop() + div.offsetHeight();
                const dragOffsetLeft = drag.offsetLeft() + (drag.offsetWidth() / 2);
                const dragOffsetTop = drag.offsetTop() + (drag.offsetHeight() / 2);

                return (dragOffsetLeft >= div.offsetLeft() && dragOffsetLeft < divOffsetRight) &&
                    (dragOffsetTop >= div.offsetTop() && dragOffsetTop < divOffsetBottom);
            },
            _TargetContainsCursor(cursor, target) {
                return cursor.X > target.offsetLeft(true) && cursor.X < target.offsetRight(true) &&
                    cursor.Y > target.offsetTop() && cursor.Y < target.offsetBottom();
            },
            _findCursorHoveredDrag(cursor, cb) {
                for (let i = 0; i < this.drags.length; ++i) {
                    let drag = this.drags[i];
                    if (this._TargetContainsCursor(cursor, drag.getDragme())) {
                        if (typeof cb === 'function')
                            cb(drag, cursor);
                        break;
                    }
                }
            },
            _findHoveredDrag(drag) {
                let foundDrag;
                for (let i = 0; i < this.drags.length; ++i) {
                    let dr = this.drags[i];
                    if (dr.getDragme() == drag.getDragme())
                        continue;
                    if (this.seekParent)
                        dr.setDragmeSeekParent();
                    if (this._divContainsDrag(drag.getDragme(), dr.getDragme())) {
                        if (this.seekParent)
                            dr.unsetDragmeSeekParent();
                        foundDrag = dr;
                        break;
                    }
                    if (this.seekParent)
                        dr.unsetDragmeSeekParent();
                }

                return foundDrag;
            }
        };

        const HTMLItems = function(elementName) {
            this.element = document.createElement(elementName);
            this._handleEvents();
        }
        HTMLItems.prototype = {
            super() {
                return HTMLItems;
            },
            render() {
                return this.element;
            },
            toString() {
                return this.render();
            },
            width(width, unit) {
                if (typeof width === 'number')
                    this.element.style.width = `${width}${unit}`;
                else
                    return this.element.style.width;
            },
            height(height, unit) {
                if (typeof height === 'number')
                    this.element.style.height = `${height}${unit}`;
                else
                    return this.element.style.height;
            },
            onDragged(cb) {
                this.element.onDragged = cb.bind(undefined, this.onDraggedEvt);
            },
            onDropped(cb) {
                this.element.onDropped = cb.bind(undefined, this.onDroppedEvt);
            },
            _handleEvents() {
                this.onDraggedEvt = new CustomEvent('dragged', {detail: {HTMLItem: this}});
                this.onDroppedEvt = new CustomEvent('dropped', {detail: {HTMLItem: this}});
            }
        }

        const Cell = function() {
            this.super().call(this, 'div');
            this.setupCell();
            this._eventManager = new ListEvents();
        }
        Cell.prototype = {
            setupCell() {
                this.element.classList.add('cell');
            },
            setEditable(editable, onEdit) {
                this.editable = editable;
                this.element.addEventListener('click', onEdit);
            },
            setDraggable(draggable) {
                if (draggable)
                    this.element.classList.add("draggable");
                else
                    this.element.classList.remove("draggable");
            },
            cellContent(content) {
                this.element.innerHTML = content;
            }
        };

        const Row = function(head) {
            this.super().call(this, 'div');
            this.setupRow(head);
            this.cells = [];
            this._isHead = head;
        }
        Row.prototype = {
            setupRow(head) {
                let className;
                if (head)
                    className = 'head';
                else
                    className = 'lonely';
                this.element.classList.add('row', className);
            },
            addCell(cell) {
                this.cells.push(cell);
            },
            isHead() {
                return this._isHead;
            },
            render() {
                if (!this.applied)
                    this.appendCells();
                return this.element;
            },
            setDraggable(draggable) {
                if (draggable)
                    this.element.classList.add('draggable');
                else
                    this.element.classList.remove('draggable');
                this.draggable = draggable;
            },
            appendCells() {
                this.applied = true;
                this.cells.forEach(cell => this.element.append(cell.render()));
            }
        };

        Object.setPrototypeOf(Cell.prototype, HTMLItems.prototype);
        Object.setPrototypeOf(Row.prototype, HTMLItems.prototype);

        const GridMaker = function(parentCnt) {
            this.parentCnt = parentCnt;
            this.rows = [];
        }
        GridMaker.prototype = {
            setRows(rows) {
                for (let i = 0; i < rows.length; ++i) {
                    this.makeRow(rows[i])
                }
            },
            setDraggable(draggable, byCell) {
                this.draggable = draggable;
                this.byCell = byCell;
            },
            isDraggable() {
                return this.draggable;
            },
            undragGrid() {
                this._unsetDraggableGrid();
            },
            makeRow(cells, autoWidth, head) {
                const row = new Row(head);
                const nbCells = cells.length;
                let cellWidth;
                if (autoWidth) {
                    cellWidth = (this.parentCnt.clientWidth / nbCells);
                }

                for (let i = 0; i < nbCells; ++i) {
                    let c = cells[i];
                    let cell = new Cell();
                    if (c.hasOwnProperty('width'))
                        cell.width(c.width, c.unit);
                    else if (autoWidth)
                        cell.width(cellWidth, c.unit);
                    if (c.hasOwnProperty('height'))
                        cell.height(c.height, c.unit);
                    if (c.hasOwnProperty('editable') && c.editable)
                        cell.setEditable(c.editable, c.onEdit);
                    if (c.hasOwnProperty('draggit') && this.byCell) {
                        cell.setDraggable(c.draggit);
                        cell.onDragged(c.onDragged);
                        cell.onDropped(c.onDropped);
                    }
                    cell.cellContent(c.content);
                    row.addCell(cell);
                }

                if (!this.byCell)
                    row.setDraggable(this.draggable);
                this.rows.push(row);
            },
            render() {
                this.rows.forEach(row => this.parentCnt.append(row.render()));
                if (this.isDraggable())
                    this._setDraggableGrid();
            },
            _setDraggableGrid() {
                if (!this.dragitManager)
                    this.dragitManager = new DragitManager();
                if (!this.byCell)
                    this.dragitManager.activate(document.querySelectorAll('.row.lonely'));
                else
                    this.dragitManager.activate(document.querySelectorAll('.cell.draggable'), true);
            },
            _unsetDraggableGrid() {
                if (!this.dragitManager)
                    return;
                this.dragitManager.deactivate();
            }
        }

        const gridMaker = new GridMaker(document.getElementById('content'));

        const nbRows = 20;
        const nbCells = 9;

        gridMaker.setDraggable(true, true);

        for (let i = 0; i < nbRows; ++i) {
            let cells = [];
            for (let y = 0; y < nbCells; ++y) {
                cells.push({
                    content: y == nbCells - 1 ? 'Dragme!' : makeid(6),
                    unit: 'px',
                    editable: false,
                    onEdit: (value) => {
                        console.log('edit value', value);
                    },
                    draggit: y == nbCells - 1 && i > 0,
                    onDragged: (evt) => {
                        evt.detail.HTMLItem.cellContent('Dropme!');
                    },
                    onDropped: (evt) => {
                        evt.detail.HTMLItem.cellContent('Dragme!');
                    }
                });
            }
            gridMaker.makeRow(cells, true, i == 0);
        }

        gridMaker.render();
    })(this, document);
    </script>
</body>
